#!/usr/bin/env python3

import praw
import re
import imgurpython
import time
import requests
import os

from lxml import etree
from subprocess import call

def main():
	"""Parses posts from /u/imgurtranscriber and posts if successful a regenerated picture as a reply to each."""

	config = open('.config', 'r')

	line = config.readline()
	while (len(line) > 0):
		if line.startswith('reddit_login'):
				reddit_login = re.search('\'(.*)\'\n', line).group(1)
		elif line.startswith('reddit_password'):
				reddit_password = re.search('\'(.*)\'\n', line).group(1)
		elif line.startswith('client_id'):
				client_id = re.search('\'(.*)\'\n', line).group(1)
		elif line.startswith('client_secret'):
				client_secret = re.search('\'(.*)\'\n', line).group(1)
		elif line.startswith('imgflip_username'):
				global imgflip_username
				imgflip_username = re.search('\'(.*)\'\n', line).group(1)
		elif line.startswith('imgflip_password'):
				global imgflip_password
				imgflip_password = re.search('\'(.*)\'\n', line).group(1)
		else:
				raise SyntaxError('Illegal line in config file')
		
		line = config.readline()

	r = praw.Reddit(user_agent='Imgur Cisscriber 0.6 by /u/Tularion')
	r.login(reddit_login, reddit_password)
	
	try:
		global client
		client = imgurpython.ImgurClient(client_id, client_secret)
	except ImgurClientError as e:
		print(e.error_message)
		print(e.status_code)
		exit()

	user = r.get_redditor('imgurtranscriber')
	comments = user.get_comments(sort='new', time='month')
	
	for comment in comments:
		if not already_replied(comment):
			meme_type = re.search('#\*\*\*(.*)\*\*\*\s*', comment.body).group(1)
			post_title = re.search('Title:\*\*\*  \*(.*)\*\s*', comment.body).group(1)
		
			search = re.search('Top:\*\*\*  \*(.*)\*\s*', comment.body)
			if search is None:
				top = ''
			else:
				top = search.group(1)
		
			search = re.search('Bottom:\*\*\*  \*(.*)\*\s*', comment.body)
			if search is None:
				bottom = ''
			else:
				bottom = search.group(1)
				
			imgur_id = re.search('http://imgur.com/([\w\d]*)', comment.body).group(1)
			
			apimeme_url = upload_from_url(generate_meme('APIMeme', meme_type, imgur_id, top, bottom))
			imgflip_url = upload_from_url(generate_meme('Imgflip', meme_type, imgur_id, top, bottom))
			captain_url = upload_from_path(generate_meme('Meme Captain', meme_type, imgur_id, top, bottom))
		
			links = [('APIMeme', apimeme_url), ('Imgflip', imgflip_url), ('Meme Captain', captain_url)]
			concat_links = list_links(links)
			
			if concat_links != "":
				comment_text = "Here is what the transcribed meme looks like in case you can't read:\n\n" + concat_links
				
				patient_reply(comment, comment_text)
				replied = open('.replied', 'a')
				replied.write(comment.id + '\n')
				replied.close()
				print('Successfully replied.\n')
			else:
				print('No links, did not reply.\n')
		else:
			print('Comment already replied to.\n')

def generate_meme(generator, meme_type, imgur_id, top, bottom):
	"""Returns a URL for the meme generated by the parameters, using the generator indicated in the first parameter. The generation may fail, then returns a URL for the failed generation.
	
	Currently uses APIMeme only."""

	if generator == 'APIMeme':
		if top is not None:
			top = top.replace(" ", "+")
		if bottom is not None:
			bottom = bottom.replace(" ", "+")

		return r'http://apimeme.com/meme?meme=' + meme_type.replace(" ", "+") + r'&top=' + top + r'&bottom=' + bottom
	elif generator == 'Imgflip':
		url = r'https://api.imgflip.com/caption_image'
		payload = {	"template_id": get_meme_data(meme_type, 'imgflipID'),
					"username": imgflip_username,
					"password": imgflip_password,
					"text0": top,
					"text1": bottom
					}
		
		r = requests.post(url, data=payload).json()
		
		if r['success']:
			return r['data']['url']
		else:
			return None
	elif generator == 'Meme Captain':
		template = get_meme_data(meme_type, 'template')
		if template is -1:
			return None
		
		path = 'templates/' + get_meme_data(meme_type, 'template')
		call(['ruby', 'captain.rb', path, top, bottom])
		if os.path.isfile('out.jpg'):
			return 'out.jpg'
		else:
			return None
		
def upload_from_path(path):
	"""Uploads an image anonymously to Imgur and returns a direct link. Returns None if upload failed."""
	
	try:
		upload = client.upload_from_path(path)
	except TypeError:
		print('Meme generation failed.')
		return None
	else:
		print('Meme generation succeeded.')
		return upload['link']

def upload_from_url(url):
	"""Uploads an image anonymously to Imgur and returns a direct link. Returns None if upload failed."""
	
	try:
		upload = client.upload_from_url(url)
	except imgurpython.helpers.error.ImgurClientError:
		print('Meme generation failed.')
		return None
	else:
		print('Meme generation succeeded.')
		return upload['link']

def already_replied(comment):
	"""Returns True if the bot has already replied to the comment, False otherwise."""

	replied = open('.replied', 'r')

	line = replied.readline()
	while (len(line) > 0):
			if line.startswith(comment.id):
					replied.close()
					return True
			line = replied.readline()
	
	replied.close()
	return False
	
def patient_reply(comment, body):
	"""Tries to reply to comment with body and waits if the rate limit is exceeded"""
	while True:
		try:
			comment.reply(body)
			break
		except reddit.errors.RateLimitExceeded as e:
			print('Rate limit exceeded, sleeping for %d seconds' % e.sleep_time)
			time.sleep(error.sleep_time)

def get_meme_data(meme_type, data_type):
	"""For a given meme type, tries to grab the indicated data from its XML node."""
	tree = etree.parse('memes.xml')
	root = tree.getroot()
	
	for elem in root.xpath('//name'):
		if meme_type in elem.text:
			try:
				return elem.xpath('../' + data_type)[0].text
			except IndexError:
				break
	
	return -1

def list_links(links):
	"""Takes a list of name/URL tuples and returns a formatted string."""
	
	comment_text = ""	
	links = [x for x in links if x[1] is not None]

	i = 0
	while i < len(links):
		comment_text += "[" + links[i][0] + " Link^" + str(i + 1) + "](" + links[i][1] + ")"
		if i < (len(links) - 1):
			comment_text += " | "
		i += 1
		
	return comment_text

main()
